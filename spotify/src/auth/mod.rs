pub mod pkce;

use crate::error::Error;
use crate::config::Config;
use djtool_model as model;
use djtool::utils::{random_string, Alphanumeric, PKCECodeVerifier};

use anyhow::Result;
use chrono::{DateTime, Duration, Utc};
use reqwest;
use reqwest::header::{HeaderMap, HeaderName, HeaderValue};
use reqwest::{Error as HttpError, Url};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use std::sync::Arc;
use tokio::sync::{Mutex, RwLock};
use webbrowser;

#[inline]
fn join_scopes(scopes: &HashSet<String>) -> String {
    scopes
        .iter()
        .map(String::as_str)
        .collect::<Vec<_>>()
        .join(" ")
}

#[derive(Debug, Clone)]
pub enum SpotifyLoginCallback {
    Pkce { code: String, state: String },
}

#[async_trait::async_trait]
pub trait Authenticator {
    async fn auth_headers(&self) -> HeaderMap;
    async fn reauthenticate(&self) -> std::result::Result<(), Error>;
    // async fn handle_user_login_callback(&self, data: SpotifyLoginCallback) -> Result<()>;
    async fn handle_user_login_callback(
        &self,
        data: model::SpotifyUserLoginCallback,
    ) -> Result<(), Error>;
}

#[derive(Debug, Clone, Default)]
pub struct Credentials {
    pub client_id: String,
    // /// PKCE doesn't require a client secret
    // pub secret: Option<String>,
}

impl Credentials {
    pub fn pkce(client_id: &str) -> Self {
        Credentials {
            client_id: client_id.to_owned(),
            // secret: None,
        }
    }
    // pub fn auth_headers(&self) -> Option<HeaderMap> {
    //     let value = format!("{}:{}", self.client_id, self.secret.as_ref()?);
    //     let value: HeaderValue = format!("Basic {}", base64::encode(value)).parse().ok()?;

    //     let mut headers = HeaderMap::new();
    //     headers.insert(HeaderName::from_static("authorization"), value);
    //     Some(headers)
    // }
}

#[derive(Debug, Clone)]
pub struct OAuth {
    pub redirect_uri: String,
    /// The state is generated by default, as suggested by the OAuth2 spec:
    /// [Cross-Site Request Forgery](https://tools.ietf.org/html/rfc6749#section-10.12)
    pub state: String,
    pub scopes: HashSet<String>,
    pub proxies: Option<String>,
}

impl Default for OAuth {
    fn default() -> Self {
        OAuth {
            redirect_uri: String::new(),
            state: random_string(16, Alphanumeric),
            scopes: HashSet::new(),
            proxies: None,
        }
    }
}
