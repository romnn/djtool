pub mod pkce;

use super::config::Config;
use crate::config::Persist;
use crate::spotify;
use crate::proto;
use crate::spotify::model::Token;
use crate::utils::{random_string, Alphanumeric, PKCECodeVerifier};
use anyhow::Result;
use async_trait::async_trait;
use base64;
use chrono::{DateTime, Duration, Utc};
use reqwest;
use reqwest::header::{HeaderMap, HeaderName, HeaderValue};
use reqwest::{Error as HttpError, Url};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::io::{Read, Write};
use std::ops::Deref;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use thiserror::Error;
use tokio::sync::{Mutex, RwLock};
use webbrowser;

#[inline]
fn join_scopes(scopes: &HashSet<String>) -> String {
    scopes
        .iter()
        .map(String::as_str)
        .collect::<Vec<_>>()
        .join(" ")
}

#[derive(Debug, Clone)]
pub enum SpotifyLoginCallback {
    Pkce { code: String, state: String },
}

#[async_trait]
pub trait Authenticator {
    async fn auth_headers(&self) -> HeaderMap;
    async fn reauthenticate(&self) -> std::result::Result<(), spotify::error::Error>;
    // async fn handle_user_login_callback(&self, data: SpotifyLoginCallback) -> Result<()>;
    async fn handle_user_login_callback(
        &self,
        data: proto::djtool::SpotifyUserLoginCallback,
    ) -> Result<(), spotify::error::Error>;
}

#[derive(Debug, Clone, Default)]
pub struct Credentials {
    pub client_id: String,
    // /// PKCE doesn't require a client secret
    // pub secret: Option<String>,
}

impl Credentials {
    pub fn pkce(client_id: &str) -> Self {
        Credentials {
            client_id: client_id.to_owned(),
            // secret: None,
        }
    }
    // pub fn auth_headers(&self) -> Option<HeaderMap> {
    //     let value = format!("{}:{}", self.client_id, self.secret.as_ref()?);
    //     let value: HeaderValue = format!("Basic {}", base64::encode(value)).parse().ok()?;

    //     let mut headers = HeaderMap::new();
    //     headers.insert(HeaderName::from_static("authorization"), value);
    //     Some(headers)
    // }
}

#[derive(Debug, Clone)]
pub struct OAuth {
    pub redirect_uri: String,
    /// The state is generated by default, as suggested by the OAuth2 spec:
    /// [Cross-Site Request Forgery](https://tools.ietf.org/html/rfc6749#section-10.12)
    pub state: String,
    pub scopes: HashSet<String>,
    pub proxies: Option<String>,
}

impl Default for OAuth {
    fn default() -> Self {
        OAuth {
            redirect_uri: String::new(),
            state: random_string(16, Alphanumeric),
            scopes: HashSet::new(),
            proxies: None,
        }
    }
}
